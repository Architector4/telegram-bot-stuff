use std::fmt::Display;

use teloxide::types::{InlineKeyboardButton, InlineKeyboardMarkup};
use url::Url;

use super::sanitized_url::SanitizedUrl;

/// A designation for a URL. Designates how to treat it.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum UrlDesignation {
    /// This URL is not spam. Ignore it and anything under it in automatic checking. But, if anyone
    /// indicates that a URL matching this rule is spam, and it wasn't manually reviewed to be not
    /// spam, send it for review.
    ///
    /// So, if `example.com/abc` is designated as this, then `example.com/abc/def` is also not spam.
    NotSpam = 0,
    /// This URL is an aggregator. It is not spam, but some things under it may or may not be spam.
    ///
    /// So, if `example.com/abc` is designated as this, then `example.com/abc/def` needs separate
    /// checking to be determined if it's spam or not.
    Aggregator = 1,
    /// This URL is spam. Everything under it is spam too.
    ///
    /// So, if `example.com/abc` is designated as this, then `example.com/abc/def` is also spam.
    Spam = 2,
}

impl TryFrom<u8> for UrlDesignation {
    type Error = ();
    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            x if x == UrlDesignation::NotSpam as u8 => Ok(UrlDesignation::NotSpam),
            x if x == UrlDesignation::Aggregator as u8 => Ok(UrlDesignation::Aggregator),
            x if x == UrlDesignation::Spam as u8 => Ok(UrlDesignation::Spam),
            _ => Err(()),
        }
    }
}

impl Display for UrlDesignation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let tha_string = match self {
            Self::NotSpam => "Not spam",
            Self::Aggregator => "Aggregator",
            Self::Spam => "Spam",
        };

        f.write_str(tha_string)
    }
}

/// Review callback data. As per telegram API for callback queries, must be serialized to below 64
/// bytes.
#[derive(Clone, Copy, Debug)]
pub struct ReviewCallbackData {
    /// ID of the URL in the review queue.
    pub review_entry_id: i64,
    /// CRC32 hash of the URL in the review queue.
    pub url_crc32: u32,
    /// New designation in the review.
    pub designation: UrlDesignation,
    /// How many times the URL in this review queue should be destructured before applying this
    /// review. Use as argument to [`SanitizedUrl::destructure_to_number`].
    pub destructure: u64,
}

impl ReviewCallbackData {
    // Manually written serialize/deserialize.
    // Doing it with derived traits with Serde and JSON or whatever would be more "proper",
    // but that typically involves allocation (can't beat a constant-size array),
    // and the serialized result is always over 64 bytes, which isn't allowed.
    //
    // I could probably still squeeze it into JSON with a bunch of effort, but this is easier lol

    /// Serialize this data. Output is valid ASCII (i.e. valid UTF-8).
    #[must_use]
    pub fn serialize(&self) -> [u8; 46] {
        let mut output = [0u8; 46];
        output[0] = b'I';
        hex::encode_to_slice(self.review_entry_id.to_le_bytes(), &mut output[1..17])
            .expect("Slice size guaranteed to be valid");
        output[17] = b'C';
        hex::encode_to_slice(self.url_crc32.to_le_bytes(), &mut output[18..26])
            .expect("Slice size guaranteed to be valid");
        output[26] = b'D';
        hex::encode_to_slice((self.designation as u8).to_le_bytes(), &mut output[27..29])
            .expect("Slice size guaranteed to be valid");
        output[29] = b'S';
        hex::encode_to_slice(self.destructure.to_le_bytes(), &mut output[30..46])
            .expect("Slice size guaranteed to be valid");

        output
    }

    /// Deserialize data. Should initially have been generated by [`Self::serialize`].
    #[must_use]
    pub fn deserialize(input: &[u8; 46]) -> Option<Self> {
        if !(input[0] == b'I' && input[17] == b'C' && input[26] == b'D' && input[29] == b'S') {
            return None;
        }

        let mut scratch = [0u8; 8];

        hex::decode_to_slice(&input[1..17], &mut scratch[0..8])
            .expect("Slice size guaranteed to be valid");
        let review_entry_id = i64::from_le_bytes(scratch);

        hex::decode_to_slice(&input[18..26], &mut scratch[0..4])
            .expect("Slice size guaranteed to be valid");
        let url_crc32 = u32::from_le_bytes(
            scratch[0..4]
                .try_into()
                .expect("Slice size guaranteed to be valid"),
        );

        hex::decode_to_slice(&input[27..29], &mut scratch[0..1])
            .expect("Slice size guaranteed to be valid");
        let designation: UrlDesignation = scratch[0].try_into().ok()?;

        hex::decode_to_slice(&input[30..46], &mut scratch[0..8])
            .expect("Slice size guaranteed to be valid");
        let destructure = u64::from_le_bytes(scratch);

        Some(Self {
            review_entry_id,
            url_crc32,
            designation,
            destructure,
        })
    }

    /// Convenience wrapper around [`Self::serialize`] that then converts the result into a string.
    #[must_use]
    pub fn serialize_to_string(&self) -> String {
        let serialized = self.serialize().to_vec();
        String::from_utf8(serialized)
            .expect("Serialized review callback is guaranteed to be valid ASCII.")
    }

    /// Convenience wrapper around [`Self::deserialize`] that tries to deserialize from a string.
    #[must_use]
    pub fn deserialize_from_str(input: &str) -> Option<Self> {
        let input: &[u8; 46] = input.as_bytes().try_into().ok()?;
        Self::deserialize(input)
    }

    /// Generates a keyboard with callback buttons for reviewing this URL with this review queue
    /// entry ID.
    ///
    /// If `destructure_down_to` is provided, buttons are only generated down to that.
    #[must_use]
    pub fn callback_buttons_from_url(
        review_entry_id: i64,
        url: &SanitizedUrl,
        destructure_down_to: Option<&SanitizedUrl>,
    ) -> InlineKeyboardMarkup {
        fn format_as_spam_text(a: &str, trim_from_start: bool) -> String {
            static LENGTH: usize = 25;

            let start = if trim_from_start {
                a.char_indices().nth_back(LENGTH).unwrap_or((0, 'g')).0
            } else {
                0
            };
            let ellipsis_start = if start > 0 { "…" } else { "" };
            let end = if trim_from_start {
                a.len()
            } else {
                a.char_indices().nth(LENGTH).unwrap_or((a.len(), 'g')).0
            };
            let ellipsis_end = if end < a.len() { "…" } else { "" };

            format!(
                "⛔️ {ellipsis_start}{}{ellipsis_end}",
                &a[start..end].trim_matches('.')
            )
        }

        let url_crc32 = crc32fast::hash(url.as_str().as_bytes());

        let mut output: Vec<Vec<InlineKeyboardButton>> =
            vec![vec![InlineKeyboardButton::callback(
                "✅ Not spam".to_string(),
                ReviewCallbackData {
                    review_entry_id,
                    url_crc32,
                    designation: UrlDesignation::NotSpam,
                    destructure: 0,
                }
                .serialize_to_string(),
            )]];

        if url.query().is_some() {
            output.push(vec![InlineKeyboardButton::callback(
                format!("⛔️ {url}"),
                ReviewCallbackData {
                    review_entry_id,
                    url_crc32,
                    designation: UrlDesignation::Spam,
                    destructure: 0,
                }
                .serialize_to_string(),
            )]);
        }

        for (i, (host, path)) in url.destructure().enumerate() {
            if let Some(down_to) = destructure_down_to {
                if host == down_to.host_str() && path == down_to.path() && i > 0 {
                    break;
                }
                // Possible case is that `url` and `destructure_down_to` are equal. In that
                // case, we want to show at least the first button, and then break after it.
                if i > 0 && url.host_str() == down_to.host_str() && url.path() == down_to.path() {
                    break;
                }
            }

            let the_str = if path.len() > 1 { path } else { host };
            let trim_from_start = path.len() > 1;

            output.push(vec![InlineKeyboardButton::callback(
                format_as_spam_text(the_str, trim_from_start),
                ReviewCallbackData {
                    review_entry_id,
                    url_crc32,
                    designation: UrlDesignation::Spam,
                    destructure: i as u64 + 1,
                }
                .serialize_to_string(),
            )]);

            if output.len() >= 50 {
                //   Maximum limit is 100 buttons iirc, but eh.
                break;
            }
        }

        InlineKeyboardMarkup {
            inline_keyboard: output,
        }
    }

    /// Given a review queue entry ID, and the URL in that entry, produces text and buttons for a
    /// review keyboard. Buttons are produced with [`Self::callback_buttons_from_url`].
    #[must_use]
    pub fn produce_review_keyboard_text_buttons(
        review_entry_id: i64,
        sanitized_url: &SanitizedUrl,
        original_url: &Url,
        destructure_down_to: Option<&SanitizedUrl>,
    ) -> (String, InlineKeyboardMarkup) {
        let text = format!("<b>REVIEW:</b>\n\n{original_url}\n\nWhat is spam here?");
        let buttons =
            Self::callback_buttons_from_url(review_entry_id, sanitized_url, destructure_down_to);

        (text, buttons)
    }
}

/// Use like this:
///
/// `format!("Deleted a message from someuser {}", delete_reason);`
#[derive(Clone, Copy, Debug)]
pub enum MessageDeleteReason {
    /// Contains a spam link.
    ContainsSpamLink,
    /// It's in an album with a message that was deemed as spam.
    OfAlbumWithSpamMessage,
}

impl MessageDeleteReason {
    /// Turn this into a string, or nothing if this reason shouldn't be printed at all.
    ///
    /// For a value like [`Self::ContainsSpamLink`] this returns "containing a spam link".
    ///
    /// For best grammar, it's recommended to prepend the output string with "Removed a message from
    /// someuser "
    ///
    ///
    #[must_use]
    pub fn to_str(self) -> Option<&'static str> {
        match self {
            Self::ContainsSpamLink => Some("containing a spam link"),
            Self::OfAlbumWithSpamMessage => None,
        }
    }
}

#[cfg(test)]
mod tests {
    #![allow(clippy::unwrap_used)]
    use super::*;

    #[test]
    fn callback_data_ser_de() {
        #[allow(clippy::cast_possible_wrap)]
        let data = ReviewCallbackData {
            review_entry_id: 0xAAAAAAAAAAAAAAAAu64 as i64,
            url_crc32: 0xBBBBBBBB,
            designation: UrlDesignation::Aggregator,
            destructure: 0xCCCCCCCCCCCCCCCC,
        };

        let serialized = data.serialize();

        assert!(serialized.is_ascii());

        let deserialized = ReviewCallbackData::deserialize(&serialized).unwrap();

        assert_eq!(data.review_entry_id, deserialized.review_entry_id);
        assert_eq!(data.url_crc32, deserialized.url_crc32);
        assert_eq!(data.designation, deserialized.designation);
        assert_eq!(data.destructure, deserialized.destructure);
    }
}
